"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[26475],{74639:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>a,default:()=>u,frontMatter:()=>s,metadata:()=>r,toc:()=>d});var o=t(85893),i=t(11151);const s={sidebar_position:8},a="Offset based connection pagination",r={id:"docs/dev-manuals/adr/graphql-connections",title:"Offset based connection pagination",description:"Context and Problem Statement",source:"@site/docs/docs/dev-manuals/adr/0007-graphql-connections.md",sourceDirName:"docs/dev-manuals/adr",slug:"/docs/dev-manuals/adr/graphql-connections",permalink:"/docs/docs/dev-manuals/adr/graphql-connections",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"docsSidebar",previous:{title:"Document the GraphQL API fully",permalink:"/docs/docs/dev-manuals/adr/graphql-documentation"},next:{title:"Storypoints",permalink:"/docs/docs/dev-manuals/adr/storypoints"}},c={},d=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3},{value:"Pros and Cons of the Options",id:"pros-and-cons-of-the-options",level:2},{value:"cursor-based pagination (according to connection specification) with totalCount support",id:"cursor-based-pagination-according-to-connection-specification-with-totalcount-support",level:3},{value:"cursor-based pagination (according to connection specification) without totalCount support",id:"cursor-based-pagination-according-to-connection-specification-without-totalcount-support",level:3},{value:"offset-based pagination with totalCount support",id:"offset-based-pagination-with-totalcount-support",level:3},{value:"offset-based pagination without totalCount support",id:"offset-based-pagination-without-totalcount-support",level:3}];function l(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.a)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.h1,{id:"offset-based-connection-pagination",children:"Offset based connection pagination"}),"\n",(0,o.jsx)(e.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,o.jsx)(e.p,{children:"APIs should support some kind of pagination when accessing a list of entities, to allow limiting API results to a managable size.\nIn GraphQL, two approaches are popular: offset based pagination, where one specifies an offset in the list, and cursor based pagination, where a string serves as cursor to some element in the list."}),"\n",(0,o.jsx)(e.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"cursor-based pagination (according to connection specification) with totalCount support"}),"\n",(0,o.jsx)(e.li,{children:"cursor-based pagination (according to connection specification) without totalCount support"}),"\n",(0,o.jsx)(e.li,{children:"offset-based pagination with totalCount support"}),"\n",(0,o.jsx)(e.li,{children:"offset-based pagination without totalCount support"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,o.jsx)(e.p,{children:'Chosen option: "offset-based pagination with totalCount support",\nbecause easier to implement, and we need totalCount support for the frontend.'}),"\n",(0,o.jsx)(e.h3,{id:"consequences",children:"Consequences"}),"\n",(0,o.jsx)(e.p,{children:"A typical GraphQL schema will look like this:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-graphql",children:'type Query {\n  "Get a list of entities"\n  entities(\n    "Number of items to skip"\n    skip: Int\n    "Number of items to return"\n    first: Int\n    "Ordering"\n    orderby: EntityOrder\n  ): EntityConnection!\n}\n\n"A connection to a list of Entity values."\ntype EntityConnection {\n  "Whether this connection has a next page"\n  hasNextPage: Boolean!\n  "The resulting entities."\n  nodes: [Entity!]!\n  "The total amount of items in this connection"\n  totalCount: Int!\n}\n\n"Entity order"\ninput EntityOrderInput {\n  "The field to order by"\n  field: EntityOrderField\n  "The direction to order by"\n  direction: OrderDirection\n}\n\n"Order direction"\nenum OrderDirection {\n  "Ascending order"\n  ASC\n  "Descending order"\n  DESC\n}\n\n"Entity order fields"\nenum EntityOrderField {\n  "Order entities by their id"\n  ID\n}\n'})}),"\n",(0,o.jsxs)(e.p,{children:["If the entity type of the connection is managed by a different service, knowledge of the entities is limited (typically only the id of the referenced entity is available).\nThus, ordering support is limited to ID.\nTo prevent conflicts between GraphQL type names, the following types MUST be used instead of ",(0,o.jsx)(e.code,{children:"EntityOrderInput"}),":"]}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-graphql",children:'"Common order"\ninput CommonOrderInput {\n  "The field to order by"\n  field: CommonOrderField\n  "The direction to order by"\n  direction: OrderDirection\n}\n\n"Common order fields"\nenum CommonOrderField {\n  "Order entities by their id"\n  ID\n}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"pros-and-cons-of-the-options",children:"Pros and Cons of the Options"}),"\n",(0,o.jsx)(e.h3,{id:"cursor-based-pagination-according-to-connection-specification-with-totalcount-support",children:"cursor-based pagination (according to connection specification) with totalCount support"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Good, because hides away technical implementation (can be offset based or different)"}),"\n",(0,o.jsxs)(e.li,{children:["Good, because standardized: ",(0,o.jsx)(e.a,{href:"https://relay.dev/graphql/connections.htm",children:"https://relay.dev/graphql/connections.htm"})]}),"\n",(0,o.jsx)(e.li,{children:"Good, because includes totalCount support, allowing clients to display the amount of pages"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because difficult to implement: cursors have to encode values of all fields used in ordering"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because does not easily allow to start at an arbitrary offset"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"cursor-based-pagination-according-to-connection-specification-without-totalcount-support",children:"cursor-based pagination (according to connection specification) without totalCount support"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Good, because hides away technical implementation (can be offset based or different)"}),"\n",(0,o.jsxs)(e.li,{children:["Good, because standardized: ",(0,o.jsx)(e.a,{href:"https://relay.dev/graphql/connections.htm",children:"https://relay.dev/graphql/connections.htm"})]}),"\n",(0,o.jsx)(e.li,{children:"Bad, because difficult to implement: cursors have to encode values of all fields used in ordering"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because does not easily allow to start at an arbitrary offset"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because clients cannot fetch the total amount of elements, which is necessary for some frontend designs"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"offset-based-pagination-with-totalcount-support",children:"offset-based pagination with totalCount support"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Good, because allows to start at arbitrary offset"}),"\n",(0,o.jsx)(e.li,{children:"Good, because easier to implement compared to cursor-based pagination (in particular with SQL databases)"}),"\n",(0,o.jsx)(e.li,{children:"Good, because includes totalCount support, allowing clients to display the amount of pages"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because less flexible than cursor-based pagination"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because non-standard"}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"offset-based-pagination-without-totalcount-support",children:"offset-based pagination without totalCount support"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Good, because allows to start at arbitrary offset"}),"\n",(0,o.jsx)(e.li,{children:"Good, because easiest to implement (in particular with SQL databases), due to missing totalCount support"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because clients cannot fetch the total amount of elements, which is necessary for some frontend designs"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because less flexible than cursor-based pagination"}),"\n",(0,o.jsx)(e.li,{children:"Bad, because non-standard"}),"\n"]})]})}function u(n={}){const{wrapper:e}={...(0,i.a)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(l,{...n})}):l(n)}},11151:(n,e,t)=>{t.d(e,{Z:()=>r,a:()=>a});var o=t(67294);const i={},s=o.createContext(i);function a(n){const e=o.useContext(s);return o.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:a(n.components),o.createElement(s.Provider,{value:e},n.children)}}}]);