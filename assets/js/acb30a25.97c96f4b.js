"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[70519],{73434:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>r,contentTitle:()=>a,default:()=>u,frontMatter:()=>i,metadata:()=>d,toc:()=>l});var t=o(85893),s=o(11151);const i={sidebar_position:2},a="Use GraphQL API Gateway",d={id:"docs/dev-manuals/adr/use-graphql-api-gateway",title:"Use GraphQL API Gateway",description:"Context and Problem Statement",source:"@site/docs/docs/dev-manuals/adr/0001-use-graphql-api-gateway.md",sourceDirName:"docs/dev-manuals/adr",slug:"/docs/dev-manuals/adr/use-graphql-api-gateway",permalink:"/docs/docs/dev-manuals/adr/use-graphql-api-gateway",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"docsSidebar",previous:{title:"Use Monolithic Frontend",permalink:"/docs/docs/dev-manuals/adr/use-monolithic-frontend"},next:{title:"Use GraphQL Federation for API Gateway",permalink:"/docs/docs/dev-manuals/adr/use-graphql-federation"}},r={},l=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3},{value:"Pros and Cons of the Options",id:"pros-and-cons-of-the-options",level:2},{value:"GraphQL",id:"graphql",level:3},{value:"REST",id:"rest",level:3},{value:"gRPC Web",id:"grpc-web",level:3}];function c(e){const n={h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,s.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"use-graphql-api-gateway",children:"Use GraphQL API Gateway"}),"\n",(0,t.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,t.jsx)(n.p,{children:"The frontend needs to be able to send requests to the backend.\nAs such requests need to be instrumented with tracing metadata, and authentication needs to be performed, an API gateway should be provided.\nHowever, different API technologies exist, and we need to decide which one to use"}),"\n",(0,t.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"GraphQL"}),"\n",(0,t.jsx)(n.li,{children:"REST"}),"\n",(0,t.jsx)(n.li,{children:"gRPC Web"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,t.jsx)(n.p,{children:'Chosen option: "GraphQL", because'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"allows frontend to use one unified API to fetch data from the backend"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Good, because allows frontend to easily fetch and combine data from different sources in the backend"}),"\n",(0,t.jsx)(n.li,{children:"Neutral, because requires us to find a way how to combine API of different services into one unified GraphQL API"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"pros-and-cons-of-the-options",children:"Pros and Cons of the Options"}),"\n",(0,t.jsx)(n.h3,{id:"graphql",children:"GraphQL"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Good, because allows frontend to easily fetch and combine data from different sources in the backend"}),"\n",(0,t.jsx)(n.li,{children:"Good, because built-in strict type system"}),"\n",(0,t.jsx)(n.li,{children:"Good, because GraphiQL allows users to explore the API, including with a graphical interface to build requests"}),"\n",(0,t.jsx)(n.li,{children:"Good, because allows client to define which data should be fetched, reducing overfetching"}),"\n",(0,t.jsx)(n.li,{children:"Good, because allows to solve N+1 problem of requests, as instead of multiple consecutive requests, a single request can define all data which needs to be fetched"}),"\n",(0,t.jsx)(n.li,{children:"Bad, because more difficult to implement, in particular regarding authorization"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"rest",children:"REST"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Good, because easiest to implement, in particular regarding authentication"}),"\n",(0,t.jsx)(n.li,{children:"Good, because easy to use for users of the reference architecture"}),"\n",(0,t.jsx)(n.li,{children:"Good, because good for browser caching"}),"\n",(0,t.jsx)(n.li,{children:"Neutral, because no built-in typing, but could be provided via OpenAPI"}),"\n",(0,t.jsx)(n.li,{children:"Bad, because more difficult to combine data from different sources: combine in gateway? have all routes from services in gateway?"}),"\n",(0,t.jsx)(n.li,{children:"Bad, because does not allow frontend to define which data should be fetched"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"grpc-web",children:"gRPC Web"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Good, because allows streaming"}),"\n",(0,t.jsx)(n.li,{children:"Good, because built-in type system"}),"\n",(0,t.jsx)(n.li,{children:"Good, because binary protocol is more efficient"}),"\n",(0,t.jsx)(n.li,{children:"Neutral, because binary format is more difficult to understand in web environment, in particular form users of the reference architecture, but text-based protocol could also be used. JSON could also be used, but it is non-standard."}),"\n",(0,t.jsx)(n.li,{children:"Bad, because less common in web environments compared to other options"}),"\n",(0,t.jsx)(n.li,{children:"Bad, because compared to GraphQL, does not provide unified way for client to define which data should be fetched"}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,s.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},11151:(e,n,o)=>{o.d(n,{Z:()=>d,a:()=>a});var t=o(67294);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);