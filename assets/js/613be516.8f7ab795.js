"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[12098],{91218:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>c});var s=i(85893),r=i(11151);const a={sidebar_position:3},o="Use GraphQL Federation for API Gateway",t={id:"docs/dev-manuals/adr/use-graphql-federation",title:"Use GraphQL Federation for API Gateway",description:"Context and Problem Statement",source:"@site/docs/docs/dev-manuals/adr/0002-use-graphql-federation.md",sourceDirName:"docs/dev-manuals/adr",slug:"/docs/dev-manuals/adr/use-graphql-federation",permalink:"/docs/docs/dev-manuals/adr/use-graphql-federation",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"docsSidebar",previous:{title:"Use GraphQL API Gateway",permalink:"/docs/docs/dev-manuals/adr/use-graphql-api-gateway"},next:{title:"Merge Category and Product Service",permalink:"/docs/docs/dev-manuals/adr/merge-category-and-product-service"}},d={},c=[{value:"Context and Problem Statement",id:"context-and-problem-statement",level:2},{value:"Considered Options",id:"considered-options",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Consequences",id:"consequences",level:3},{value:"Pros and Cons of the Options",id:"pros-and-cons-of-the-options",level:2},{value:"GraphQL Mesh / Schema stitching",id:"graphql-mesh--schema-stitching",level:3},{value:"GraphQL Federation",id:"graphql-federation",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",ul:"ul",...(0,r.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"use-graphql-federation-for-api-gateway",children:"Use GraphQL Federation for API Gateway"}),"\n",(0,s.jsx)(n.h2,{id:"context-and-problem-statement",children:"Context and Problem Statement"}),"\n",(0,s.jsx)(n.p,{children:"As we decided to use GraphQL for the API gateway, we need a technology which allows us to combine the API of different services into one unified GraphQL API."}),"\n",(0,s.jsx)(n.h2,{id:"considered-options",children:"Considered Options"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"GraphQL Mesh / Schema stitching"}),"\n",(0,s.jsx)(n.li,{children:"GraphQL Federation"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"decision-outcome",children:"Decision Outcome"}),"\n",(0,s.jsx)(n.p,{children:'Chosen option: "GraphQL Federation", because'}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Combining different GraphQL APIs simpler than combinding non-GraphQL APIs (in particular regarding type merging), and GraphQL federation is easier to use in this case"}),"\n",(0,s.jsx)(n.li,{children:"Flexibility of GraphQL Mesh not required when using GraphQL Federation compatible GraphQL APIs"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"consequences",children:"Consequences"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Neutral, because requires us to setup a GraphQL Federation compatiple API gateway (router)"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because requires each service to provide a GraphQL Federation compatible GraphQL API"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"pros-and-cons-of-the-options",children:"Pros and Cons of the Options"}),"\n",(0,s.jsx)(n.h3,{id:"graphql-mesh--schema-stitching",children:"GraphQL Mesh / Schema stitching"}),"\n",(0,s.jsx)(n.p,{children:"GraphQL Mesh is a library allowing to combine multiple data sources into one unified GraphQL API.\nSupported data formats include other GraphQL APIs, REST APIs, gRPC APIs, and more."}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good, because flexible: allows to combine different data sources"}),"\n",(0,s.jsx)(n.li,{children:"Good, because allows to transform API schemas before combining them"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because only provides significant benefits when used with non-GraphQL APIs, but e.g. using REST APIs results in challenges, in particular with respect to combining types"}),"\n",(0,s.jsx)(n.li,{children:"Bad, because more complex to use compared to GraphQL federation"}),"\n",(0,s.jsxs)(n.li,{children:["Bad, because combining the same type from one service is only partially supported. However, this is often required when using REST, e.g. because same service provides a ",(0,s.jsx)(n.code,{children:"Product"})," and ",(0,s.jsx)(n.code,{children:"ProductWithDetails"})]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"graphql-federation",children:"GraphQL Federation"}),"\n",(0,s.jsx)(n.p,{children:"Also known as Apollo Federation, allows to combine multiple GraphQL APIs (subgraphs) into one unified GraphQL API (supergraph)"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Good, because integration into GraphQL libraries for different programming languages widely available"}),"\n",(0,s.jsx)(n.li,{children:"Good, because API gateway easy to set-up and configure: only requires schemas of combined subgraphs"}),"\n",(0,s.jsx)(n.li,{children:"Good, because can still be used with GraphQL Mesh if required"}),"\n",(0,s.jsx)(n.li,{children:"Neutral, because forces each service to provide a GraphQL API: while limiting flexibility, also enforces some uniformity in the backend architecture"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},11151:(e,n,i)=>{i.d(n,{Z:()=>t,a:()=>o});var s=i(67294);const r={},a=s.createContext(r);function o(e){const n=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(a.Provider,{value:n},e.children)}}}]);